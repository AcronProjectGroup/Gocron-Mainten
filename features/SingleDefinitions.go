package features

type SingleDefinitions struct {
	SingleDef map[string]string
}

var OriginSingleDef = SingleDefinitions{

	SingleDef: map[string]string{
		// Introduction
		"go":               "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"golang":           "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"gopher":           "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"gophers":          "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"what is go?":      "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"what is go ?":     "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"what is golang?":  "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"what is golang ?": "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		// Go documentation
		"godoc":                      "Godoc is a Go package that lets you create, manage, and use Go documentation in “the Go way”. for installing: sudo apt install golang-golang-x-tools. The Go way is a set of principles that, as a Go programmer, you should follow to improve code quality. Using Godoc, you can easily read other developers' documentation and code. You can also automate the creation of your own documentation and publish it using Godoc.Godoc is similar to Javadoc, the code documentor for Java. They both use comments and code in modules to generate documentation. And both tools structure that documentation in HTML so you can view it in a browser.",
		"what is godoc?":             "Godoc is a Go package that lets you create, manage, and use Go documentation in “the Go way”. for installing: sudo apt install golang-golang-x-tools. The Go way is a set of principles that, as a Go programmer, you should follow to improve code quality. Using Godoc, you can easily read other developers' documentation and code. You can also automate the creation of your own documentation and publish it using Godoc.Godoc is similar to Javadoc, the code documentor for Java. They both use comments and code in modules to generate documentation. And both tools structure that documentation in HTML so you can view it in a browser.",
		"install godoc":              "Run this in Terminal ===> sudo apt install golang-golang-x-tools",
		"getting started with godoc": "install the Godoc package from the golang website using this command: go get golang.org/x/tools/cmd/godoc. Conventionally, Go developers use port 6060 to host documentation. This is the command for running a Godoc server on that port: godoc -http=:6060 .  The command above hosts your code documentation on localhost, or 127.0.0.1. The port doesn't have to 6060; godoc will run on any unoccupied port. However, it's always best to follow the Go documentation conventions.",
		"about go":                   "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev.",

		"create environment go":      "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"create go project":          "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"go project":                 "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"environment go":             "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"go environment":             "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"create go environment":      "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"run go environment":         "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"run go environment project": "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"build":                      "1.build: The go build command compiles the source code in the current directory and generates an executable file.",
		"clean":                      "2.clean: The go clean command removes the output produced by the go build command,  including the executable and any temporary files that were created during the build.",
		"flag":                       "5.flag package: Command-line flags are a common way to specify options for command-line programs. For example, in wc -l the -l is a command-line flag. Go provides a flag package supporting basic command-line flag parsing. We'll use this package to implement our example command-line program.",
		"flag package":               "5.flag package: Command-line flags are a common way to specify options for command-line programs. For example, in wc -l the -l is a command-line flag. Go provides a flag package supporting basic command-line flag parsing. We'll use this package to implement our example command-line program.",
		"goroutine":                  "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"go routine":                 "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"goroutines":                 "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"channels":                   "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"goroutines and channels":    "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"channels and goroutines":    "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"regular expressions":        "189.Regular Expressions: The regular expressions used in this section perform basic matches, but the regexp package supports an extensive pattern syntax, which is described at https://pkg.go.dev/regexp/syntax@go1.17.1.",
		"regularexpressions":         "189.Regular Expressions: The regular expressions used in this section perform basic matches, but the regexp package supports an extensive pattern syntax, which is described at https://pkg.go.dev/regexp/syntax@go1.17.1.",
		"regex":                      "189.Regular Expressions: The regular expressions used in this section perform basic matches, but the regexp package supports an extensive pattern syntax, which is described at https://pkg.go.dev/regexp/syntax@go1.17.1.",
		"currying":                   "Currying: Function currying is the practice of writing a function that takes a function (or functions) as input, and returns a new function.",
		"trimspace(s)":               "TrimSpace(s): This function returns the string s without leading or trailing whitespace characters.",
		"trim(s, set)":               "Trim(s, set): This function returns a string from which any leading or trailing characters contained in the string set are removed from the string s.",
		"trimLeft(s, set)":           "This function returns the string s without any leading character contained in the string set. This function matches any of the specified characters—use the TrimPrefix function to remove a complete substring.",
		"trimright(s, set)":          "This function returns the string s without any trailing character contained in the string set. This function matches any of the specified characters—use the TrimSuffix function to remove a complete substring.",
		"trimprefix(s, prefix)":      "function returns the string s after removing the specified prefix string. This function removes the complete prefix string—use the TrimLeft function to remove characters from a set.",
		"trimsuffix(s, suffix)":      "function returns the string s after removing the specified suffix string. This function removes the complete suffix string—use the TrimRight function to remove characters from a set.",
		"trimfunc(s, func)":          "TrimFunc(s, func): This function returns the string s from which any leading or trailing character for which a custom function returns true are removed.",
		"trimleftFunc(s, func)":      "TrimLeftFunc(s, func): function returns the string s from which any leading character for which a custom function returns true are removed.",
		"trimrightFunc(s,    func)":  "TrimRightFunc(s, func): function returns the string s from which any trailing character for which a custom function returns true are removed.",
		"for":                        "56.for: Go allows loops only inside of functions. The for keyword is used to create loops that repeatedly execute statements. The most basic for loops will repeat indefinitely unless interrupted by the break keyword Incorporating the Condition into the Loop",
		"package":                    "Go applications are organized in packages. A package is a collection of source files located in the same directory. All source files in a directory must share the same package name. When a package is imported, only entities (functions, types, variables, constants) whose names start with a capital letter can be used / accessed. The recommended style of naming in Go is that identifiers will be named using camelCase, except for those meant to be accessible across packages which should be PascalCase. EXAMPLE: || package lasagna || ",
		"packages":                   "Go applications are organized in packages. A package is a collection of source files located in the same directory. All source files in a directory must share the same package name. When a package is imported, only entities (functions, types, variables, constants) whose names start with a capital letter can be used / accessed. The recommended style of naming in Go is that identifiers will be named using camelCase, except for those meant to be accessible across packages which should be PascalCase. EXAMPLE: || package lasagna || ",
		"variable":                   "Variables Go is statically-typed, which means all variables must have a defined type at compile-time.Variables can be defined by explicitly specifying a type, EXAMPLE: var explicit int || Explicitly typed||",
		"variables":                  "Variables Go is statically-typed, which means all variables must have a defined type at compile-time.Variables can be defined by explicitly specifying a type, EXAMPLE: var explicit int || Explicitly typed||",



		"constant":                   "Constants hold a piece of data just like variables, but their value cannot change during the execution of the program.Constants are defined using the const keyword and can be numbers, characters, strings or booleans. EXAMPLE:	const Age = 21",
		"constants":                  "Constants hold a piece of data just like variables, but their value cannot change during the execution of the program.Constants are defined using the const keyword and can be numbers, characters, strings or booleans. EXAMPLE:	const Age = 21",
		"function":                   "Go functions accept zero or more parameters. Parameters must be explicitly typed, there is no type inference. Values are returned from functions using the return keyword. A function is invoked by specifying the function name and passing arguments for each of the function's parameters.",
		"functions":                  "Go functions accept zero or more parameters. Parameters must be explicitly typed, there is no type inference. Values are returned from functions using the return keyword. A function is invoked by specifying the function name and passing arguments for each of the function's parameters.",
		"comment":                    "Note that Go supports two types of comments. Single line comments are preceded by // and multiline comments are inserted between /* and */.",
		"comments":                   "Note that Go supports two types of comments. Single line comments are preceded by // and multiline comments are inserted between /* and */.",
		"bool":                       "Booleans in Go are represented by the predeclared boolean type bool, which values can be either true or false. It's a defined type.",
		"boolean":                    "Booleans in Go are represented by the predeclared boolean type bool, which values can be either true or false. It's a defined type.",
		"booleans":                   "Booleans in Go are represented by the predeclared boolean type bool, which values can be either true or false. It's a defined type.",
		"package comments":           "Package comments should be written directly before a package clause (package x) and begin with Package x ...",
		"package comment":            "Package comments should be written directly before a package clause (package x) and begin with Package x ...",
		"function comment":           "A function comment should be written directly before the function declaration. It should be a full sentence that starts with the function name. For example, an exported comment for the function Calculate should take the form Calculate .... It should also explain what arguments the function takes, what it does with them, and what its return values mean, ending in a period):",
		"function comments":          "A function comment should be written directly before the function declaration. It should be a full sentence that starts with the function name. For example, an exported comment for the function Calculate should take the form Calculate .... It should also explain what arguments the function takes, what it does with them, and what its return values mean, ending in a period):",
		"number":                     "Go contains basic numeric types that can represent sets of either integer or floating-point values.",
		"numbers":                    "Go contains basic numeric types that can represent sets of either integer or floating-point values.",
		"int":                        "e.g. 0, 255, 2147483647. A signed integer that is at least 32 bits in size (value range of: -2147483648 through 2147483647). But this will depend on the systems architecture. Most modern computers are 64 bit, therefore int will be 64 bits in size (value rate of: -9223372036854775808 through 9223372036854775807).",
		"float64":                    "e.g. 0.0, 3.14. Contains the set of all 64-bit floating-point numbers.",
		"uint":                       "e.g. 0, 255. An unsigned integer that is the same size as int (value range of: 0 through 4294967295 for 32 bits and 0 through 18446744073709551615 for 64 bits)",
		"arithmetic operators":       "Go supports many standard arithmetic operators EXAMPLE: + , - , / , % ",
		"operator":                   "Go supports many standard arithmetic operators EXAMPLE: + , - , / , % ",
		"operators":                  "Go supports many standard arithmetic operators EXAMPLE: + , - , / , % ",
		"basic operator":             "Go supports many standard arithmetic operators EXAMPLE: + , - , / , % ",
		"basic operators":            "Go supports many standard arithmetic operators EXAMPLE: + , - , / , % ",
		"converting between types":   "Converting between types is done via a function with the name of the type to convert to. ",
	
		"arithmetic operations on different types": "In many languages you can perform arithmetic operations on different types of variables, but in Go this gives an error. ",
		"string": "A string in Go is an immutable sequence of bytes, which don't necessarily have to represent characters.",
		// using reflection
		"reflection":                    "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"reflections":                   "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"using reflection":              "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"what is reflection?":           "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"what is reflection ?":          "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"what is reflection in Go?":     "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"what is reflection in Go ?":    "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"why is reflection useful?":     "Reflection is useful when writing code that relies on types that will be defined in the future, such as when writing an API that will be used in other projects. use this word for get example: reflection example",
		"why is reflection useful ?":    "Reflection is useful when writing code that relies on types that will be defined in the future, such as when writing an API that will be used in other projects. use this word for get example: reflection example",
		"why is a reflection useful?":   "Reflection is useful when writing code that relies on types that will be defined in the future, such as when writing an API that will be used in other projects. use this word for get example: reflection example",
		"why is a reflection useful ?":  "Reflection is useful when writing code that relies on types that will be defined in the future, such as when writing an API that will be used in other projects. use this word for get example: reflection example",
		"how is reflection used?":       "The reflect package provides features that allow types and values to be reflected, such that they can be used without explicit knowledge of the data types in use.  use this word for get example: reflection example",
		"how is reflection used ?":      "The reflect package provides features that allow types and values to be reflected, such that they can be used without explicit knowledge of the data types in use.  use this word for get example: reflection example",
		"why the need for reflection?":  "The Go type system is rigorously enforced, which means you can't use a value of one type when a different type is inspected. sometime this is broken for wrong implementing. in this case, the empty interface, which can be used to accept any type.  use this word for get example: reflection example",
		"why the need for reflection ?": "The Go type system is rigorously enforced, which means you can't use a value of one type when a different type is inspected. sometime this is broken for wrong implementing. in this case, the empty interface, which can be used to accept any type.  use this word for get example: reflection example",
		"reflect package":               "The reflect package provides the Go reflection features, and the key functions are called TypeOf and ValueOf",
		// Generics
		"generic":                "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"generics":               "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"what is the generics":   "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"what is the generics?":  "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"what is the generics ?": "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"go generics":            "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"generics go":            "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"generics in go":         "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		// Frameworks
		"beego":           "beego is used for rapid development of RESTful APIs, web apps and backend services in Go. It is inspired by Tornado, Sinatra and Flask. beego has some Go-specific features such as interfaces and struct embedding. Package beego provide a MVC framework beego: an open-source, high-performance, modular, full-stack web framework It is used for rapid development of RESTful APIs, web apps and backend services in Go. beego is inspired by Tornado, Sinatra and Flask with the added benefit of some Go-specific features such as interfaces and struct embedding.",
		"beego framework": "beego is used for rapid development of RESTful APIs, web apps and backend services in Go. It is inspired by Tornado, Sinatra and Flask. beego has some Go-specific features such as interfaces and struct embedding. Package beego provide a MVC framework beego: an open-source, high-performance, modular, full-stack web framework It is used for rapid development of RESTful APIs, web apps and backend services in Go. beego is inspired by Tornado, Sinatra and Flask with the added benefit of some Go-specific features such as interfaces and struct embedding.",
		// Database
		"database":                                         "There are drivers for a wide range of databases, and a list can be found at  https://github.com/golang/go/wiki/sqldrivers",
		"data base":                                        "There are drivers for a wide range of databases, and a list can be found at  https://github.com/golang/go/wiki/sqldrivers",
		"what is the database?":                            "The database/sql package provides features for working with SQL databases.",
		"what is the sql package?":                         "The database/sql package provides features for working with SQL databases.",
		"what is the database-sql package?":                "The database/sql package provides features for working with SQL databases.",
		"what is the database/sql package?":                "The database/sql package provides features for working with SQL databases.",
		"how is the database used?":                        "Relational databases remain the most effective way of storing large amounts of structured data and are used in most large projects.",
		"how is the database/sql used?":                    "Relational databases remain the most effective way of storing large amounts of structured data and are used in most large projects.",
		"Are in database any pitfalls or limitations?":     "These features do not automatically populate struct fields from result rows.",
		"Are in database/sql any pitfalls or limitations?": "These features do not automatically populate struct fields from result rows.",
		"Are in sql any pitfalls or limitations?":          "These features do not automatically populate struct fields from result rows.",
		"installing a database driver":                     "Run the command:==> go get modernc.org/sqlite  Most database servers are set up separately so that the database driver opens a connection to a separate process. SQLite is an embedded database and is included in the driver package, which means no additional configuration is required.",
		// Apache kafka
		"kafka":        "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"apacheKafka":  "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"apache Kafka": "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"what is exactly kafka apache for golang?":  "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"what is exactly kafka apache for golang ?": "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"what is kafka apache for golang?":          "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"what is kafka apache for golang ?":         "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		// Packages
		"strings":         "The strings package contains many useful functions to work on strings. For more information about string functions, check out the strings package documentation. Link: https://pkg.go.dev/strings",
		"package tar":     "Package tar implements access to tar archives.",
		"package zip":     "Package zip provides support for reading and writing ZIP archives.",
		"package arena":   "The arena package provides the ability to allocate memory for a collection of Go values and free that space manually all at once, safely.",
		"package bufio":   "bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O. ",
		"package builtin": "Package builtin provides documentation for Go's predeclared identifiers.",
		"package bytes":   "bytes implements functions for the manipulation of byte slices.",
		"package cmp":     "Package cmp provides types and functions related to comparing ordered values. Ordered is a constraint that permits any ordered type: any type // that supports the operators < <= >= >.// If future releases of Go add new ordered types,// this constraint will be modified to include them.",
		"package bzip2":   "Package bzip2 implements bzip2 decompression.",
		"package flate":   "Package flate implements the DEFLATE compressed data format, described in RFC 1951.",
		"package gzip":    "Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.",
		"package lzw":     "Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, “A Technique for High-Performance Data Compression”, Computer, 17(6) (June 1984), pp 8-19. ",
		"package zlib":    "Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950. ",
		"package reflect": "The reflect package provides features that allow types and values to be reflected, such that they can be used without explicit knowledge of the data types in use.",
		// server
		"server": "server is a service for connection between clients and hosts. for get example of Go please write this: server example",
		// 487.Identifying Byte Slices
		"identifying byte slices": "Using the comparison operator is also a good way of using the Bytes method safety. The Bytes method will panic if it is called on any type other than a slice of bytes, but the Kind method only indicates slices and not their contents.",
		//
		// 488.go tool dist list
		"go tool dist list": `488🚀 This will provide you a list of operating systems and architectures separated by / characters:`,
		"tool dist list":    `488🚀 This will provide you a list of operating systems and architectures separated by / characters:`,
		"dist list":         `488🚀 This will provide you a list of operating systems and architectures separated by / characters:`,
		// ioutil
		"ioutil": "The ioutil package in Go stands for 'input/output utility.' It is a package in the Go standard library that provides utility functions for I/O operations, particularly simplifying common tasks involving file I/O and reading from or writing to streams of data.",
		// Others
		"fuzzing":            "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today’s date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		"fuzzing definition": "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today’s date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		"fuzzing define":     "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today’s date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		"what is fuzzing":    "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today’s date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		"what is fuzzing?":   "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today’s date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		"what is fuzzing ?":  "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today’s date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		// Split
		"split()":                      "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"split() func":                 "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"split() function":             "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"what is the split() function": "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"what is split() function":     "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"what is split() ?":            "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"what is split()?":             "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"what is split()":              "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		//
		//
		//
		//
		//
		//
		//
		//
		//
		//
		//
		//
		//
		//
		// ==================================== FUNCTIONS ==============================================
		//47.Atoi(str) 49.FormatInt(val, base) 50.FormatUint(val, base)
		"atoi()":                 "47🚀 Atoi(str) 🔔 This function parses a string into a base 10 int and is equivalent to calling ParseInt(str, 10, 0)",
		"atoi(str)":              "47🚀 Atoi(str) 🔔 This function parses a string into a base 10 int and is equivalent to calling ParseInt(str, 10, 0)",
		"atoi(string)":           "47🚀 Atoi(str) 🔔 This function parses a string into a base 10 int and is equivalent to calling ParseInt(str, 10, 0)",
		"formatint()":            "49🚀 FormatInt(value, base) 🔔 This function returns a string representation of the specified int64 value, expressed in the specified base.",
		"formatint(value, base)": "49🚀 FormatInt(value, base) 🔔 This function returns a string representation of the specified int64 value, expressed in the specified base.",
		"formatint(val, base)":   "49🚀 FormatInt(value, base) 🔔 This function returns a string representation of the specified int64 value, expressed in the specified base.",
		"formatuint()":           "50🚀 FormatUint(val, base) 🔔 This function returns a string representation of the specified uint64 value, expressed in the specified base.",
		"formatuint(val, base)":  "50🚀 FormatUint(val, base) 🔔 This function returns a string representation of the specified uint64 value, expressed in the specified base.",
		//51.FormatFloat(val, format, precision, size)
		"formatfloat()":                             "51🚀 FormatFloat(val, format, precision, size) 🔔 This function returns a string representation of the specified float64 value, expressed using the specified format, precision, and size.",
		"formatfloat(1,2,3,4)":                      "51🚀 FormatFloat(val, format, precision, size) 🔔This function returns a string representation of the specified float64 value, expressed using the specified format, precision, and size.",
		"formatfloat(val, format, precision, size)": "51🚀 FormatFloat(val, format, precision, size) 🔔This function returns a string representation of the specified float64 value, expressed using the specified format, precision, and size.",
		//52.Itoa(val)
		"itoa()":      "52🚀 Itoa(val) 🔔 This function returns a string representation of the specified int value, expressed using base 10.",
		"itoa(val)":   "52🚀 Itoa(val) 🔔 This function returns a string representation of the specified int value, expressed using base 10.",
		"itoa(value)": "52🚀 Itoa(val) 🔔 This function returns a string representation of the specified int value, expressed using base 10.",
		// 165.Working with Character Case
		"islower(rune)":  "165🚀 IsLower(rune) 🔔 This function returns true if the specified rune is lowercase.",
		"islower()":      "165🚀 IsLower(rune) 🔔 This function returns true if the specified rune is lowercase.",
		"islower(r)":     "165🚀 IsLower(rune) 🔔 This function returns true if the specified rune is lowercase.",
		"islower(runes)": "165🚀 IsLower(rune) 🔔 This function returns true if the specified rune is lowercase.",
		"tolower(rune)":  "165🚀 ToLower(rune) 🔔 This function returns the lowercase rune associated with the specified rune.",
		"tolower()":      "165🚀 ToLower(rune) 🔔 This function returns the lowercase rune associated with the specified rune.",
		"tolower(r)":     "165🚀 ToLower(rune) 🔔 This function returns the lowercase rune associated with the specified rune.",
		"tolower(runes)": "165🚀 ToLower(rune) 🔔 This function returns the lowercase rune associated with the specified rune.",
		"isupper(rune)":  "165🚀 IsUpper(rune) 🔔 This function returns true if the specified rune is uppercase.",
		"isupper(r)":     "165🚀 IsUpper(rune) 🔔 This function returns true if the specified rune is uppercase.",
		"isupper(runes)": "165🚀 IsUpper(rune) 🔔 This function returns true if the specified rune is uppercase.",
		"isupper()":      "165🚀 IsUpper(rune) 🔔 This function returns true if the specified rune is uppercase.",
		"toupper(rune)":  "165🚀 ToUpper(rune) 🔔 This function returns the upper rune associated with the specified rune.",
		"toupper()":      "165🚀 ToUpper(rune) 🔔 This function returns the upper rune associated with the specified rune.",
		"toupper(r)":     "165🚀 ToUpper(rune) 🔔 This function returns the upper rune associated with the specified rune.",
		"toupper(runes)": "165🚀 ToUpper(rune) 🔔 This function returns the upper rune associated with the specified rune.",
		"istitle(rune)":  "165🚀 IsTitle(rune) 🔔 This function returns true if the specified rune is title case.",
		"istitle()":      "165🚀 IsTitle(rune) 🔔 This function returns true if the specified rune is title case.",
		"istitle(r)":     "165🚀 IsTitle(rune) 🔔 This function returns true if the specified rune is title case.",
		"istitle(runes)": "165🚀 IsTitle(rune) 🔔 This function returns true if the specified rune is title case.",
		"totitle(rune)":  "165🚀 ToTitle(rune) 🔔 This function returns the title case rune associated with the specified rune.",
		"totitle()":      "165🚀 ToTitle(rune) 🔔 This function returns the title case rune associated with the specified rune.",
		"totitle(r)":     "165🚀 ToTitle(rune) 🔔 This function returns the title case rune associated with the specified rune.",
		"totitle(runes)": "165🚀 ToTitle(rune) 🔔 This function returns the title case rune associated with the specified rune.",
		// 167.Inspecting Strings || The strings Functions for Inspecting Strings
		"count(s, sub)":                    "167🚀 Count(s, sub) 🔔 This function returns an int that reports how many times the specified substring is found in the string s.",
		"count()":                          "167🚀 Count(s, sub) 🔔 This function returns an int that reports how many times the specified substring is found in the string s.",
		"count(string, sub)":               "167🚀 Count(s, sub) 🔔 This function returns an int that reports how many times the specified substring is found in the string s.",
		"index(s, sub)":                    "167🚀 Index(s, sub) 🔔 These functions return the index of the first or last occurrence of a specified",
		"index()":                          "167🚀 Index(s, sub) 🔔 These functions return the index of the first or last occurrence of a specified",
		"index(string, sub)":               "167🚀 Index(s, sub) 🔔 These functions return the index of the first or last occurrence of a specified",
		"indexany(s, chars)":               "167🚀 IndexAny(s, chars) 🔔 These functions return the first or last occurrence of any character in the...",
		"indexany()":                       "167🚀 IndexAny(s, chars) 🔔 These functions return the first or last occurrence of any character in the...",
		"indexany(string, characters)":     "167🚀 IndexAny(s, chars) 🔔 These functions return the first or last occurrence of any character in the...",
		"lastindexAny(s, chars)":           "167🚀 LastIndexAny(s, chars) 🔔 specified string within the string s, or -1 if there is no occurrence.",
		"lastindexAny()":                   "167🚀 LastIndexAny(s, chars) 🔔 specified string within the string s, or -1 if there is no occurrence.",
		"lastindexAny(string, characters)": "167🚀 LastIndexAny(s, chars) 🔔 specified string within the string s, or -1 if there is no occurrence.",
		"indexbyte(s, b)":                  "167🚀 IndexByte(s, b) 🔔 These functions return the index of the first or last occurrence of a specified",
		"indexbyte()":                      "167🚀 IndexByte(s, b) 🔔 These functions return the index of the first or last occurrence of a specified",
		"indexbyte(string, byte)":          "167🚀 IndexByte(s, b) 🔔 These functions return the index of the first or last occurrence of a specified",
		"lastindexByte(s, b)":              "167🚀 LastIndexByte(s, b) 🔔 byte within the string s, or -1 if there is no occurrence.",
		"lastindexByte()":                  "167🚀 LastIndexByte(s, b) 🔔 byte within the string s, or -1 if there is no occurrence.",
		"lastindexByte(string, byte)":      "167🚀 LastIndexByte(s, b) 🔔 byte within the string s, or -1 if there is no occurrence.",
		"indexfunc(s, func)":               "167🚀 IndexFunc(s, func) 🔔 These functions return the index of the first or last occurrence of the...",
		"indexfunc()":                      "167🚀 IndexFunc(s, func) 🔔 These functions return the index of the first or last occurrence of the...",
		"indexfunc(string, function)":      "167🚀 IndexFunc(s, func) 🔔 These functions return the index of the first or last occurrence of the...",
		"lastindexFunc(s, func)":           "167🚀 LastIndexFunc(s, func) 🔔  character in the string s for which the specified function returns true, as described in the “Inspecting Strings with Custom Functions” section.",
		"lastindexFunc()":                  "167🚀 LastIndexFunc(s, func) 🔔  character in the string s for which the specified function returns true, as described in the “Inspecting Strings with Custom Functions” section.",
		"lastindexFunc(string, function)":  "167🚀 LastIndexFunc(s, func) 🔔  character in the string s for which the specified function returns true, as described in the “Inspecting Strings with Custom Functions” section.",
		//161.Comparing Strings
		"contains(s, substr)":            "161🚀 Contains(s, substr) 🔔 This function returns true if the string s contains substr and false if it does not.",
		"contains()":                     "161🚀 Contains(s, substr) 🔔 This function returns true if the string s contains substr and false if it does not.",
		"contains(string, substring)":    "161🚀 Contains(s, substr) 🔔 This function returns true if the string s contains substr and false if it does not.",
		"containsany(s, substr)":         "161🚀 ContainsAny(s, substr) 🔔 This function returns true if the string s contains any of the characters contained in the string substr.",
		"containsany()":                  "161🚀 ContainsAny(s, substr) 🔔 This function returns true if the string s contains any of the characters contained in the string substr.",
		"containsany(string, substring)": "161🚀 ContainsAny(s, substr) 🔔 This function returns true if the string s contains any of the characters contained in the string substr.",
		"containsrune(s, rune)":          "161🚀 ContainsRune(s, rune) 🔔 This function returns true if the string s contains a specific rune.",
		"containsrune()":                 "161🚀 ContainsRune(s, rune) 🔔 This function returns true if the string s contains a specific rune.",
		"containsrune(string, rune)":     "161🚀 ContainsRune(s, rune) 🔔 This function returns true if the string s contains a specific rune.",
		"containsrune(string, r)":        "161🚀 ContainsRune(s, rune) 🔔 This function returns true if the string s contains a specific rune.",
		"containsrune(string, R)":        "161🚀 ContainsRune(s, rune) 🔔 This function returns true if the string s contains a specific rune.",
		"containsrune(s, R)":             "161🚀 ContainsRune(s, rune) 🔔 This function returns true if the string s contains a specific rune.",
		"containsrune(S, R)":             "161🚀 ContainsRune(s, rune) 🔔 This function returns true if the string s contains a specific rune.",
		"equalfold(s1, s2)":              "161🚀 EqualFold(s1, s2) 🔔 This function performs a case-insensitive comparison and returns true of strings s1 and s2 are the same.",
		"equalfold()":                    "161🚀 EqualFold(s1, s2) 🔔 This function performs a case-insensitive comparison and returns true of strings s1 and s2 are the same.",
		"equalfold(string, string)":      "161🚀 EqualFold(s1, s2) 🔔 This function performs a case-insensitive comparison and returns true of strings s1 and s2 are the same.",
		"equalfold(string1, string2)":    "161🚀 EqualFold(s1, s2) 🔔 This function performs a case-insensitive comparison and returns true of strings s1 and s2 are the same.",
		"hasprefix(s, prefix)":           "161🚀 HasPrefix(s, prefix) 🔔 This function returns true if the string s begins with the string prefix.",
		"hasprefix(s, p)":                "161🚀 HasPrefix(s, prefix) 🔔 This function returns true if the string s begins with the string prefix.",
		"hasprefix(string, p)":           "161🚀 HasPrefix(s, prefix) 🔔 This function returns true if the string s begins with the string prefix.",
		"hasprefix(string, prefix)":      "161🚀 HasPrefix(s, prefix) 🔔 This function returns true if the string s begins with the string prefix.",
		"hasprefix()":                    "161🚀 HasPrefix(s, prefix) 🔔 This function returns true if the string s begins with the string prefix.",
		"hassuffix(s, suffix)":           "161🚀 HasSuffix(s, suffix) 🔔 This function returns true if the string ends with the string suffix.",
		"hassuffix(s, suf)":              "161🚀 HasSuffix(s, suffix) 🔔 This function returns true if the string ends with the string suffix.",
		"hassuffix(string, suf)":         "161🚀 HasSuffix(s, suffix) 🔔 This function returns true if the string ends with the string suffix.",
		"hassuffix(string, sufix)":       "161🚀 HasSuffix(s, suffix) 🔔 This function returns true if the string ends with the string suffix.",
		"hassuffix()":                    "161🚀 HasSuffix(s, suffix) 🔔 This function returns true if the string ends with the string suffix.",
		"hassuffix(string, string)":      "161🚀 HasSuffix(s, suffix) 🔔 This function returns true if the string ends with the string suffix.",
		// 169.Splitting Strings
		"fields(s)":                     "169🚀 Fields(s) 🔔 This function splits a string on whitespace characters and returns a slice containing the nonwhitespace sections of the string s.",
		"fields()":                      "169🚀 Fields(s) 🔔 This function splits a string on whitespace characters and returns a slice containing the nonwhitespace sections of the string s.",
		"fields(string)":                "169🚀 Fields(s) 🔔 This function splits a string on whitespace characters and returns a slice containing the nonwhitespace sections of the string s.",
		"fieldsfunc(s, func)":           "169🚀 FieldsFunc(s, func) 🔔 This function splits the string s on the characters for which a custom function returns true and returns a slice containing the remaining sections of the string.",
		"fieldsfunc()":                  "169🚀 FieldsFunc(s, func) 🔔 This function splits the string s on the characters for which a custom function returns true and returns a slice containing the remaining sections of the string.",
		"fieldsfunc(string, function)":  "169🚀 FieldsFunc(s, func) 🔔 This function splits the string s on the characters for which a custom function returns true and returns a slice containing the remaining sections of the string.",
		"split(s, sub)":                 "169🚀 Split(s, sub) 🔔 This function splits the string s on every occurrence of the specified substring, returning a string slice. If the separator is the empty string, then the slice will contain strings for each character.",
		"split()":                       "169🚀 Split(s, sub) 🔔 This function splits the string s on every occurrence of the specified substring, returning a string slice. If the separator is the empty string, then the slice will contain strings for each character.",
		"split(string, sub)":            "169🚀 Split(s, sub) 🔔 This function splits the string s on every occurrence of the specified substring, returning a string slice. If the separator is the empty string, then the slice will contain strings for each character.",
		"splitn(s, sub, max)":           "169🚀 SplitN(s, sub, max) 🔔 This function is similar to Split, but accepts an additional int argument that specifies the maximum number of substrings to return. The last substring in the result slice will contain the unsplit portion of the source string.",
		"splitn()":                      "169🚀 SplitN(s, sub, max) 🔔 This function is similar to Split, but accepts an additional int argument that specifies the maximum number of substrings to return. The last substring in the result slice will contain the unsplit portion of the source string.",
		"splitn(string, sub, max)":      "169🚀 SplitN(s, sub, max) 🔔 This function is similar to Split, but accepts an additional int argument that specifies the maximum number of substrings to return. The last substring in the result slice will contain the unsplit portion of the source string.",
		"splitafter(s, sub)":            "169🚀 SplitAfter(s, sub) 🔔 This function is similar to Split but includes the substring used in the results.",
		"splitafter()":                  "169🚀 SplitAfter(s, sub) 🔔 This function is similar to Split but includes the substring used in the results.",
		"splitafter(string, sub)":       "169🚀 SplitAfter(s, sub) 🔔 This function is similar to Split but includes the substring used in the results.",
		"splitaftern(s, sub, max)":      "169🚀 SplitAfterN(s, sub, max) 🔔 This function is similar to SplitAfter, but accepts an additional int argument that specifies the maximum number of substrings to return.",
		"splitaftern()":                 "169🚀 SplitAfterN(s, sub, max) 🔔 This function is similar to SplitAfter, but accepts an additional int argument that specifies the maximum number of substrings to return.",
		"splitaftern(string, sub, max)": "169🚀 SplitAfterN(s, sub, max) 🔔 This function is similar to SplitAfter, but accepts an additional int argument that specifies the maximum number of substrings to return.",
		// 179.Altering Strings
		"replace(s, old, new, n)":           "179🚀 Replace(s, old, new, n) 🔔 This function alters the string s by replacing occurrences of the string old with the string new. The maximum number of occurrences that will be replaced is specified by the int argument n.",
		"replace()":                         "179🚀 Replace(s, old, new, n) 🔔 This function alters the string s by replacing occurrences of the string old with the string new. The maximum number of occurrences that will be replaced is specified by the int argument n. Replace(s): This method returns a string for which all the replacements specified with the constructor have been performed on the string s.",
		"replace(1, 2, 3, 4)":               "179🚀 Replace(s, old, new, n) 🔔 This function alters the string s by replacing occurrences of the string old with the string new. The maximum number of occurrences that will be replaced is specified by the int argument n.",
		"replace(1,2,3,4)":                  "179🚀 Replace(s, old, new, n) 🔔 This function alters the string s by replacing occurrences of the string old with the string new. The maximum number of occurrences that will be replaced is specified by the int argument n.",
		"replace(string, old, new, number)": "179🚀 Replace(s, old, new, n) 🔔 This function alters the string s by replacing occurrences of the string old with the string new. The maximum number of occurrences that will be replaced is specified by the int argument n.",
		"replaceall(s, old, new)":           "179🚀 ReplaceAll(s, old, new) 🔔 This function alters the string s by replacing all occurrences of the string old with the string new. Unlike the Replace function, there is no limit on the number of occurrences that will be replaced.",
		"replaceall()":                      "179🚀 ReplaceAll(s, old, new) 🔔 This function alters the string s by replacing all occurrences of the string old with the string new. Unlike the Replace function, there is no limit on the number of occurrences that will be replaced.",
		"replaceall(string, old, new)":      "179🚀 ReplaceAll(s, old, new) 🔔 This function alters the string s by replacing all occurrences of the string old with the string new. Unlike the Replace function, there is no limit on the number of occurrences that will be replaced.",
		"map(func, s)":                      "179🚀 Map(func, s) 🔔 This function generates a string by invoking the custom function for each character in the string s and concatenating the results. If the function produces a negative value, the current character is dropped without a replacement.",
		"map()":                             "179🚀 Map(func, s) 🔔 This function generates a string by invoking the custom function for each character in the string s and concatenating the results. If the function produces a negative value, the current character is dropped without a replacement.",
		"map(function, string)":             "179🚀 Map(func, s) 🔔 This function generates a string by invoking the custom function for each character in the string s and concatenating the results. If the function produces a negative value, the current character is dropped without a replacement.",
		//183.The Replacer Methods
		"replace(s)":             "183🚀 Replace(s) 🔔 This method returns a string for which all the replacements specified with the constructor have been performed on the string s. Replace(s): This method returns a string for which all the replacements specified with the constructor have been performed on the string s.",
		"replace(string)":        "183🚀 Replace(s) 🔔 This method returns a string for which all the replacements specified with the constructor have been performed on the string s.",
		"replace(str)":           "183🚀 Replace(s) 🔔 This method returns a string for which all the replacements specified with the constructor have been performed on the string s.",
		"writestring(writer, s)": "183🚀 WriteString(writer, s) 🔔 This method is used to perform the replacements specified with the constructor and write the results to an io.Writer. This method is used to perform the replacements specified with the constructor and write the results to an io.Writer",
		"writestring(w, s)":      "183🚀 WriteString(writer, s) 🔔 This method is used to perform the replacements specified with the constructor and write the results to an io.Writer",
		"writestring(w, str)":    "183🚀 WriteString(writer, s) 🔔 This method is used to perform the replacements specified with the constructor and write the results to an io.Writer",
		"writestring(w, string)": "183🚀 WriteString(writer, s) 🔔 This method is used to perform the replacements specified with the constructor and write the results to an io.Writer",
		//184.Building and Generating Strings
		"join(slice, sep)":       "184🚀 Join(slice, sep) 🔔 This function combines the elements in the specified string slice, with the specified separator string placed between elements. Join(slice, sep): function combines the elements in the specified string slice, with the specified separator string placed between elements.",
		"join(slice, specified)": "184🚀 Join(slice, sep) 🔔 This function combines the elements in the specified string slice, with the specified separator string placed between elements.",
		"join()":                 "184🚀 Join(slice, sep) 🔔 This function combines the elements in the specified string slice, with the specified separator string placed between elements.",
		"repeat(s, count)":       "184🚀 Repeat(s, count) 🔔 This function generates a string by repeating the string s for a specified number of times.",
		"repeat(str, count)":     "184🚀 Repeat(s, count) 🔔 This function generates a string by repeating the string s for a specified number of times.",
		//186.Building Strings
		"writestring(s)":      "186🚀 WriteString(s) 🔔 This method appends the string s to the string being built.",
		"writestring(string)": "186🚀 WriteString(s) 🔔 This method appends the string s to the string being built.",
		"writestring()":       "186🚀 WriteString(s) 🔔 This method appends the string s to the string being built.",
		"writerune(r)":        "186🚀 WriteRune(r) 🔔 This method appends the character r to the string being built.",
		"writerune()":         "186🚀 WriteRune(r) 🔔 This method appends the character r to the string being built.",
		"writebyte(b)":        "186🚀 WriteByte(b) 🔔 This method appends the byte b to the string being built.",
		"writebyte(byte)":     "186🚀 WriteByte(b) 🔔 This method appends the byte b to the string being built.",
		"writebyte()":         "186🚀 WriteByte(b) 🔔 This method appends the byte b to the string being built.",
		"string()":            "186🚀 String() 🔔 This method returns the string that has been created by the builder.",
		"reset()":             "186🚀 Reset() 🔔 This method resets the string created by the builder.",
		"len()":               "186🚀 Len() 🔔 This method returns the number of bytes used to store the string created by the builder.",
		"cap()":               "186🚀 Cap() 🔔 This method returns the number of bytes that have been allocated by the builder.",
		"grow(size)":          "186🚀 Grow(size) 🔔 This method increases the number of bytes used allocated by the builder to store the string that is being built.",
		"grow(siz)":           "186🚀 Grow(size) 🔔 This method increases the number of bytes used allocated by the builder to store the string that is being built.",
		"grow(sizes)":         "186🚀 Grow(size) 🔔 This method increases the number of bytes used allocated by the builder to store the string that is being built.",
		//192.Useful Basic Regexp Methods
		"matchstring(s)":                   "192🚀 MatchString(s) 🔔 This method returns true if the string s matches the compiled pattern.",
		"matchstring(str)":                 "192🚀 MatchString(s) 🔔 This method returns true if the string s matches the compiled pattern.",
		"matchstring(string)":              "192🚀 MatchString(s) 🔔 This method returns true if the string s matches the compiled pattern.",
		"matchstring(strings)":             "192🚀 MatchString(s) 🔔 This method returns true if the string s matches the compiled pattern.",
		"findstringindex(s)":               "192🚀 FindStringIndex(s) 🔔 This method returns an int slice containing the location for the left most match made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findstringindex(str)":             "192🚀 FindStringIndex(s) 🔔 This method returns an int slice containing the location for the left most match made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findstringindex(string)":          "192🚀 FindStringIndex(s) 🔔 This method returns an int slice containing the location for the left most match made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findstringindex(strings)":         "192🚀 FindStringIndex(s) 🔔 This method returns an int slice containing the location for the left most match made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findallstringindex(s, max)":       "192🚀 FindAllStringIndex(s, max) 🔔 This method returns a slice of int slices that contain the location for all the matches made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findallstringindex(str, max)":     "192🚀 FindAllStringIndex(s, max) 🔔 This method returns a slice of int slices that contain the location for all the matches made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findallstringindex(string, max)":  "192🚀 FindAllStringIndex(s, max) 🔔 This method returns a slice of int slices that contain the location for all the matches made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findallstringindex(strings, max)": "192🚀 FindAllStringIndex(s, max) 🔔 This method returns a slice of int slices that contain the location for all the matches made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findstring(s)":                    "192🚀 FindString(s) 🔔 This method returns a string containing the left-most match made by the compiled pattern in the string s. An empty string will be returned if no match is made.",
		"findstring(str)":                  "192🚀 FindString(s) 🔔 This method returns a string containing the left-most match made by the compiled pattern in the string s. An empty string will be returned if no match is made.",
		"findstring(string)":               "192🚀 FindString(s) 🔔 This method returns a string containing the left-most match made by the compiled pattern in the string s. An empty string will be returned if no match is made.",
		"findstring(strings)":              "192🚀 FindString(s) 🔔 This method returns a string containing the left-most match made by the compiled pattern in the string s. An empty string will be returned if no match is made.",
		"findallstring(s, max)":            "192🚀 FindAllString(s, max) 🔔 This method returns a string slice containing the matches made by the compiled pattern in the string s. The int argument max specifies the maximum number of matches, with -1 specifying no limit. A nil result is returned if there are no matches.",
		"findallstring(str, max)":          "192🚀 FindAllString(s, max) 🔔 This method returns a string slice containing the matches made by the compiled pattern in the string s. The int argument max specifies the maximum number of matches, with -1 specifying no limit. A nil result is returned if there are no matches.",
		"findallstring(string, max)":       "192🚀 FindAllString(s, max) 🔔 This method returns a string slice containing the matches made by the compiled pattern in the string s. The int argument max specifies the maximum number of matches, with -1 specifying no limit. A nil result is returned if there are no matches.",
		"split(s, max)":                    "192🚀 Split(s, max) 🔔 This method splits the string s using matches from the compiled pattern as separators and returns a slice containing the split substrings.",
		"split(str, max)":                  "192🚀 Split(s, max) 🔔 This method splits the string s using matches from the compiled pattern as separators and returns a slice containing the split substrings.",
		"split(string, max)":               "192🚀 Split(s, max) 🔔 This method splits the string s using matches from the compiled pattern as separators and returns a slice containing the split substrings.",
		// 197.The Regexp Methods for Subexpressions
		"findstringsubmatch(s)":              "197🚀 FindStringSubmatch(s) 🔔 This method returns a slice containing the first match made by the pattern and the text for the subexpressions that the pattern defines.",
		"findstringsubmatch(str)":            "197🚀 FindStringSubmatch(s) 🔔 This method returns a slice containing the first match made by the pattern and the text for the subexpressions that the pattern defines.",
		"findstringsubmatch(string)":         "197🚀 FindStringSubmatch(s) 🔔 This method returns a slice containing the first match made by the pattern and the text for the subexpressions that the pattern defines.",
		"findallstringsubmatch(s, max)":      "197🚀 FindAllStringSubmatch(s, max) 🔔 This method returns a slice containing all the matches and the text for the subexpressions. The int argument is used to specify the maximum number of matches. A value of -1 specifies all matches.",
		"findallstringsubmatch(str, max)":    "197🚀 FindAllStringSubmatch(s, max) 🔔 This method returns a slice containing all the matches and the text for the subexpressions. The int argument is used to specify the maximum number of matches. A value of -1 specifies all matches.",
		"findallstringsubmatch(string, max)": "197🚀 FindAllStringSubmatch(s, max) 🔔 This method returns a slice containing all the matches and the text for the subexpressions. The int argument is used to specify the maximum number of matches. A value of -1 specifies all matches.",
		"findstringsubmatchindex(s)":         "197🚀 FindStringSubmatchIndex(s) 🔔 This method is equivalent to FindStringSubmatch but returns indices rather than substrings. FindAllStringSubmatchIndex",
		"findstringsubmatchindex(str)":       "197🚀 FindStringSubmatchIndex(s) 🔔 This method is equivalent to FindStringSubmatch but returns indices rather than substrings. FindAllStringSubmatchIndex",
		"findstringsubmatchindex(string)":    "197🚀 FindStringSubmatchIndex(s) 🔔 This method is equivalent to FindStringSubmatch but returns indices rather than substrings. FindAllStringSubmatchIndex",
		"numsubexp()":                        "197🚀 NumSubexp() 🔔 This method returns the number of subexpressions.",
		"subexpindex(name)":                  "197🚀 SubexpIndex(name) 🔔 This method returns the index of the subexpression with the specified name or -1 if there is no such subexpression.",
		"subexpindex(names)":                 "197🚀 SubexpIndex(name) 🔔 This method returns the index of the subexpression with the specified name or -1 if there is no such subexpression.",
		"subexpindex(n)":                     "197🚀 SubexpIndex(name) 🔔 This method returns the index of the subexpression with the specified name or -1 if there is no such subexpression.",
		"subexpnames()":                      "197🚀 SubexpNames() 🔔 This method returns the names of the subexpressions, expressed in the order in which they are defined.",
		//199.Replacing Substrings Using a Regular Expression
		"replaceallstring(s, template)":              "199🚀 ReplaceAllString(s, template) 🔔 This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallstring(str, temp)":                "199🚀 ReplaceAllString(s, template) 🔔 This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallstring(string, temp)":             "199🚀 ReplaceAllString(s, template) 🔔 This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallstring(strings, temp)":            "199🚀 ReplaceAllString(s, template) 🔔 This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallstring(strings, template)":        "199🚀 ReplaceAllString(s, template) 🔔 This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallstring(string, template)":         "199🚀 ReplaceAllString(s, template) 🔔 This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallliteralstring(s, sub)":            "199🚀 ReplaceAllLiteralString(s, sub) 🔔 This method replaces the matched portion of the string s with the specified content, which is included in the result without being expanded for subexpressions.",
		"replaceallliteralstring(str, sub)":          "199🚀 ReplaceAllLiteralString(s, sub) 🔔 This method replaces the matched portion of the string s with the specified content, which is included in the result without being expanded for subexpressions.",
		"replaceallliteralstring(string, sub)":       "199🚀 ReplaceAllLiteralString(s, sub) 🔔 This method replaces the matched portion of the string s with the specified content, which is included in the result without being expanded for subexpressions.",
		"replaceallliteralstring(string, specified)": "199🚀 ReplaceAllLiteralString(s, sub) 🔔 This method replaces the matched portion of the string s with the specified content, which is included in the result without being expanded for subexpressions.",
		"replaceallstringfunc(s, func)":              "199🚀 ReplaceAllStringFunc(s, func) 🔔 This method replaces the matched portion of the string s with the result produced by the specified function.",
		"replaceallstringfunc(str, func)":            "199🚀 ReplaceAllStringFunc(s, func) 🔔 This method replaces the matched portion of the string s with the result produced by the specified function.",
		"replaceallstringfunc(string, function)":     "199🚀 ReplaceAllStringFunc(s, func) 🔔 This method replaces the matched portion of the string s with the result produced by the specified function.",
		// 203.fmt package
		"print(...vals)":            "203🚀 Print(...vals) 🔔 This function accepts a variable number of arguments and writes out their values to the standard out. Spaces are added between values that are not strings.",
		"print()":                   "203🚀 Print(...vals) 🔔 This function accepts a variable number of arguments and writes out their values to the standard out. Spaces are added between values that are not strings.",
		"print(...)":                "203🚀 Print(...vals) 🔔 This function accepts a variable number of arguments and writes out their values to the standard out. Spaces are added between values that are not strings.",
		"print(...values)":          "203🚀 Print(...vals) 🔔 This function accepts a variable number of arguments and writes out their values to the standard out. Spaces are added between values that are not strings.",
		"println(...vals)":          "203🚀 Println(...vals) 🔔 This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"println(vals)":             "203🚀 Println(...vals) 🔔 This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"println()":                 "203🚀 Println(...vals) 🔔 This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"println(values)":           "203🚀 Println(...vals) 🔔 This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"println(...value)":         "203🚀 Println(...vals) 🔔 This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"println(...)":              "203🚀 Println(...vals) 🔔 This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"fprint(writer, ...vals)":   "203🚀 Fprint(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer, Spaces are added between values that are not strings.",
		"fprint(w, ...vals)":        "203🚀 Fprint(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer, Spaces are added between values that are not strings.",
		"fprint(w, vals)":           "203🚀 Fprint(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer, Spaces are added between values that are not strings.",
		"fprint()":                  "203🚀 Fprint(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer, Spaces are added between values that are not strings.",
		"fprint(wr, vals)":          "203🚀 Fprint(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer, Spaces are added between values that are not strings.",
		"fprintln(writer, ...vals)": "203🚀 Fprintln(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(wri, ...vals)":    "203🚀 Fprintln(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(w, ...vals)":      "203🚀 Fprintln(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(w, vals)":         "203🚀 Fprintln(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(w, values)":       "203🚀 Fprintln(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(w, v)":            "203🚀 Fprintln(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln()":                "203🚀 Fprintln(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(wrt, vls)":        "203🚀 Fprintln(writer, ...vals) 🔔 This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		//206.The fmt Functions for Formatting Strings
		"sprintf(t, ...vals)":         "206🚀 Sprintf(t, ...vals) 🔔 This function returns a string, which is created by processing the template t.",
		"sprintf(t, vals)":            "206🚀 Sprintf(t, ...vals) 🔔 This function returns a string, which is created by processing the template t.",
		"sprintf()":                   "206🚀 Sprintf(t, ...vals) 🔔 This function returns a string, which is created by processing the template t.",
		"sprintf(1,...2)":             "206🚀 Sprintf(t, ...vals) 🔔 This function returns a string, which is created by processing the template t.",
		"printf(t, ...vals)":          "206🚀 Printf(t, ...vals) 🔔 This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to the standard out.",
		"printf(t, ...)":              "206🚀 Printf(t, ...vals) 🔔 This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to the standard out.",
		"printf()":                    "206🚀 Printf(t, ...vals) 🔔 This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to the standard out.",
		"printf(1,2)":                 "206🚀 Printf(t, ...vals) 🔔 This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to the standard out.",
		"printf(1,...2)":              "206🚀 Printf(t, ...vals) 🔔 This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to the standard out.",
		"fprintf(writer, t, ...vals)": "206🚀 Fprintf(writer, t, ...vals) 🔔 This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to a Writer, which is described in Chapter 20.",
		"fprintf(write, t, ...vals)":  "206🚀 Fprintf(writer, t, ...vals) 🔔 This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to a Writer, which is described in Chapter 20.",
		"fprintf()":                   "206🚀 Fprintf(writer, t, ...vals) 🔔 This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to a Writer, which is described in Chapter 20.",
		"fprintf(1,2,3)":              "206🚀 Fprintf(writer, t, ...vals) 🔔 This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to a Writer, which is described in Chapter 20.",
		"errorf(t, ...values)":        "206🚀 Errorf(t, ...values) 🔔 This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		"errorf(t, ...val)":           "206🚀 Errorf(t, ...values) 🔔 This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		"errorf(t, ...vals)":          "206🚀 Errorf(t, ...values) 🔔 This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		"errorf()":                    "206🚀 Errorf(t, ...values) 🔔 This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		"errorf(1,2)":                 "206🚀 Errorf(t, ...values) 🔔 This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		"errorf(1,...2)":              "206🚀 Errorf(t, ...values) 🔔 This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		// 220.The fmt Functions for Scanning Strings
		"scan(...vals)":                       "220🚀 Scan(...vals) 🔔 This function reads text from the standard in and stores the space- separated values into specified arguments. Newlines are treated as spaces, and the function reads until it has received values for all of its arguments. The result is the number of values that have been read and an error that describes any problems.",
		"scan(...)":                           "220🚀 Scan(...vals) 🔔 This function reads text from the standard in and stores the space- separated values into specified arguments. Newlines are treated as spaces, and the function reads until it has received values for all of its arguments. The result is the number of values that have been read and an error that describes any problems.",
		"scan()":                              "220🚀 Scan(...vals) 🔔 This function reads text from the standard in and stores the space- separated values into specified arguments. Newlines are treated as spaces, and the function reads until it has received values for all of its arguments. The result is the number of values that have been read and an error that describes any problems.",
		"scan(...2)":                          "220🚀 Scan(...vals) 🔔 This function reads text from the standard in and stores the space- separated values into specified arguments. Newlines are treated as spaces, and the function reads until it has received values for all of its arguments. The result is the number of values that have been read and an error that describes any problems.",
		"scanln(...vals)":                     "220🚀 Scanln(...vals) 🔔 This function works in the same way as Scan but stops reading when it encounters a newline character.",
		"scanln(...)":                         "220🚀 Scanln(...vals) 🔔 This function works in the same way as Scan but stops reading when it encounters a newline character.",
		"scanln()":                            "220🚀 Scanln(...vals) 🔔 This function works in the same way as Scan but stops reading when it encounters a newline character.",
		"scanln(...2)":                        "220🚀 Scanln(...vals) 🔔 This function works in the same way as Scan but stops reading when it encounters a newline character.",
		"scanf(template, ...vals)":            "220🚀 Scanf(template, ...vals) 🔔 This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"scanf(temp, ...vals)":                "220🚀 Scanf(template, ...vals) 🔔 This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"scanf(temp, ...values)":              "220🚀 Scanf(template, ...vals) 🔔 This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"scanf(1,2)":                          "220🚀 Scanf(template, ...vals) 🔔 This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"scanf(1,...2)":                       "220🚀 Scanf(template, ...vals) 🔔 This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"scanf()":                             "220🚀 Scanf(template, ...vals) 🔔 This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"fscan(reader, ...vals)":              "220🚀 Fscan(reader, ...vals) 🔔 This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscan(reade, ...vals)":               "220🚀 Fscan(reader, ...vals) 🔔 This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscan(reader, ...values)":            "220🚀 Fscan(reader, ...vals) 🔔 This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscan(reader, values)":               "220🚀 Fscan(reader, ...vals) 🔔 This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscan(1,2)":                          "220🚀 Fscan(reader, ...vals) 🔔 This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscan()":                             "220🚀 Fscan(reader, ...vals) 🔔 This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscanln(reader, ...vals)":            "220🚀 Fscanln(reader, ...vals) 🔔 This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanln(reader, ...values)":          "220🚀 Fscanln(reader, ...vals) 🔔 This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanln(reader, values)":             "220🚀 Fscanln(reader, ...vals) 🔔 This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanln(read, values)":               "220🚀 Fscanln(reader, ...vals) 🔔 This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanln(1,2)":                        "220🚀 Fscanln(reader, ...vals) 🔔 This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanln()":                           "220🚀 Fscanln(reader, ...vals) 🔔 This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanf(reader, template, ...vals)":   "220🚀 Fscanf(reader, template, ...vals) 🔔 This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(reader, template, ...values)": "220🚀 Fscanf(reader, template, ...vals) 🔔 This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(reader, template, values)":    "220🚀 Fscanf(reader, template, ...vals) 🔔 This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(reader, temp, values)":        "220🚀 Fscanf(reader, template, ...vals) 🔔 This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(read, temp, values)":          "220🚀 Fscanf(reader, template, ...vals) 🔔 This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(read, temp, val)":             "220🚀 Fscanf(reader, template, ...vals) 🔔 This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(read, temp, vals)":            "220🚀 Fscanf(reader, template, ...vals) 🔔 This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(1,2,3)":                       "220🚀 Fscanf(reader, template, ...vals) 🔔 This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(1, 2, 3)":                     "220🚀 Fscanf(reader, template, ...vals) 🔔 This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf()":                            "220🚀 Fscanf(reader, template, ...vals) 🔔 This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"sscan(str, ...vals)":                 "220🚀 Sscan(str, ...vals) 🔔 This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(str, vals)":                    "220🚀 Sscan(str, ...vals) 🔔 This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(str, values)":                  "220🚀 Sscan(str, ...vals) 🔔 This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(string, values)":               "220🚀 Sscan(str, ...vals) 🔔 This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(string, ...values)":            "220🚀 Sscan(str, ...vals) 🔔 This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan()":                             "220🚀 Sscan(str, ...vals) 🔔 This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(1,2)":                          "220🚀 Sscan(str, ...vals) 🔔 This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(1, 2)":                         "220🚀 Sscan(str, ...vals) 🔔 This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscanf(str, template, ...vals)":      "220🚀 Sscanf(str, template, ...vals) 🔔 This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(string, template, ...vals)":   "220🚀 Sscanf(str, template, ...vals) 🔔 This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(string, template, vals)":      "220🚀 Sscanf(str, template, ...vals) 🔔 This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(string, template, values)":    "220🚀 Sscanf(str, template, ...vals) 🔔 This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(str, template, values)":       "220🚀 Sscanf(str, template, ...vals) 🔔 This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(str, temp, values)":           "220🚀 Sscanf(str, template, ...vals) 🔔 This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(str, temp, vals)":             "220🚀 Sscanf(str, template, ...vals) 🔔 This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(1,2,3)":                       "220🚀 Sscanf(str, template, ...vals) 🔔 This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(1, 2, 3)":                     "220🚀 Sscanf(str, template, ...vals) 🔔 This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf()":                            "220🚀 Sscanf(str, template, ...vals) 🔔 This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanln(str, template, ...vals)":     "220🚀 Sscanln(str, template, ...vals) 🔔 This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(string, template, ...vals)":  "220🚀 Sscanln(str, template, ...vals) 🔔 This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(string, template, vals)":     "220🚀 Sscanln(str, template, ...vals) 🔔 This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(string, template, values)":   "220🚀 Sscanln(str, template, ...vals) 🔔 This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(str, temp, vals)":            "220🚀 Sscanln(str, template, ...vals) 🔔 This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(str, template, vals)":        "220🚀 Sscanln(str, template, ...vals) 🔔 This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(str, template, values)":      "220🚀 Sscanln(str, template, ...vals) 🔔 This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(1,2,3)":                      "220🚀 Sscanln(str, template, ...vals) 🔔 This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(1, 2, 3)":                    "220🚀 Sscanln(str, template, ...vals) 🔔 This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln()":                           "220🚀 Sscanln(str, template, ...vals) 🔔 This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		//226.Useful Functions from the math Package
		"abs(val)":         "226🚀 Abs(val) 🔔 This function returns the absolute value of a float64 value, meaning the distance from zero without considering direction.",
		"abs()":            "226🚀 Abs(val) 🔔 This function returns the absolute value of a float64 value, meaning the distance from zero without considering direction.",
		"ceil(val)":        "226🚀 Ceil(val) 🔔 This function returns the smallest integer that is equal to or greater than the specified float64 value. The result is also a float64 value, even though it represents an integer number.",
		"ceil()":           "226🚀 Ceil(val) 🔔 This function returns the smallest integer that is equal to or greater than the specified float64 value. The result is also a float64 value, even though it represents an integer number.",
		"copysign(x, y)":   "226🚀 Copysign(x, y) 🔔 This function returns a float64 value, which is the absolute value of x with the sign of y.",
		"copysign(1,2)":    "226🚀 Copysign(x, y) 🔔 This function returns a float64 value, which is the absolute value of x with the sign of y.",
		"copysign(1, 2)":   "226🚀 Copysign(x, y) 🔔 This function returns a float64 value, which is the absolute value of x with the sign of y.",
		"copysign()":       "226🚀 Copysign(x, y) 🔔 This function returns a float64 value, which is the absolute value of x with the sign of y.",
		"floor(val)":       "226🚀 Floor(val) 🔔 This function returns the largest integer that is smaller or equal to the specified float64 value. The result is also a float64 value, even though it represents an integer number.",
		"floor()":          "226🚀 Floor(val) 🔔 This function returns the largest integer that is smaller or equal to the specified float64 value. The result is also a float64 value, even though it represents an integer number.",
		"max(x, y)":        "226🚀 Max(x, y) 🔔 This function returns whichever of the specified float64 value is the largest.",
		"max(x,y)":         "226🚀 Max(x, y) 🔔 This function returns whichever of the specified float64 value is the largest.",
		"max(1,2)":         "226🚀 Max(x, y) 🔔 This function returns whichever of the specified float64 value is the largest.",
		"max(1, 2)":        "226🚀 Max(x, y) 🔔 This function returns whichever of the specified float64 value is the largest.",
		"max()":            "226🚀 Max(x, y) 🔔 This function returns whichever of the specified float64 value is the largest.",
		"min(x, y)":        "226🚀 Min(x, y) 🔔 This function returns whichever of the specified float64 value is smallest.",
		"min(x,y)":         "226🚀 Min(x, y) 🔔 This function returns whichever of the specified float64 value is smallest.",
		"min(1,2)":         "226🚀 Min(x, y) 🔔 This function returns whichever of the specified float64 value is smallest.",
		"min(1, 2)":        "226🚀 Min(x, y) 🔔 This function returns whichever of the specified float64 value is smallest.",
		"min()":            "226🚀 Min(x, y) 🔔 This function returns whichever of the specified float64 value is smallest.",
		"mod(x, y)":        "226🚀 Mod(x, y) 🔔 This function returns the remainder of x/y.",
		"mod(x,y)":         "226🚀 Mod(x, y) 🔔 This function returns the remainder of x/y.",
		"mod(1,2)":         "226🚀 Mod(x, y) 🔔 This function returns the remainder of x/y.",
		"mod(1, 2)":        "226🚀 Mod(x, y) 🔔 This function returns the remainder of x/y.",
		"mod()":            "226🚀 Mod(x, y) 🔔 This function returns the remainder of x/y.",
		"pow(x, y)":        "226🚀 Pow(x, y) 🔔 This function returns x raised to the exponent y.",
		"pow(x,y)":         "226🚀 Pow(x, y) 🔔 This function returns x raised to the exponent y.",
		"pow()":            "226🚀 Pow(x, y) 🔔 This function returns x raised to the exponent y.",
		"pow(1,2)":         "226🚀 Pow(x, y) 🔔 This function returns x raised to the exponent y.",
		"pow(1, 2)":        "226🚀 Pow(x, y) 🔔 This function returns x raised to the exponent y.",
		"round(val)":       "226🚀 Round(val) 🔔 This function rounds the specified value to the nearest integer, rounding half values up. The result is a float64 value, even though it represents an integer.",
		"round()":          "226🚀 Round(val) 🔔 This function rounds the specified value to the nearest integer, rounding half values up. The result is a float64 value, even though it represents an integer.",
		"roundtoeven(val)": "226🚀 RoundToEven(val) 🔔 This function rounds the specified value to the nearest integer, rounding half values to the nearest even number. The result is a float64 value, even though it represents an integer.",
		"roundtoeven()":    "226🚀 RoundToEven(val) 🔔 This function rounds the specified value to the nearest integer, rounding half values to the nearest even number. The result is a float64 value, even though it represents an integer.",
		//228.Generating Random Numbers
		"seed(s)":              "228 🚀 Seed(s) 🔔 This function sets the seed value using the specified int64 value.",
		"seed()":               "228 🚀 Seed(s) 🔔 This function sets the seed value using the specified int64 value.",
		"float32()":            "228 🚀 Float32() 🔔 This function generates a random float32 value between 0 and 1.",
		"float64()":            "228 🚀 Float64() 🔔 This function generates a random float64 value between 0 and 1.",
		"int()":                "228 🚀 Int() 🔔 This function generates a random int value.",
		"intn(max)":            "228 🚀 Intn(max) 🔔 This function generates a random int smaller than a specified value, as described after the table.",
		"intn()":               "228 🚀 Intn(max) 🔔 This function generates a random int smaller than a specified value, as described after the table.",
		"uint32()":             "228 🚀 UInt32() 🔔 This function generates a random uint32 value.",
		"uint64()":             "228 🚀 UInt64() 🔔 This function generates a random uint64 value.",
		"shuffle(count, func)": "228 🚀 Shuffle(count, func) 🔔 This function is used to randomize the order of elements, as described after the table.",
		//234.The Basic Functions for Sorting
		"float64s(slice)":          "234🚀 Float64s(slice) 🔔 This function sorts a slice of float64 values. The elements are sorted in place.",
		"float64s()":               "234🚀 Float64s(slice) 🔔 This function sorts a slice of float64 values. The elements are sorted in place.",
		"float64saresorted(slice)": "234🚀 Float64sAreSorted(slice) 🔔 This function returns true if the elements in the specified float64 slice are in order.",
		"float64saresorted()":      "234🚀 Float64sAreSorted(slice) 🔔 This function returns true if the elements in the specified float64 slice are in order.",
		"ints(slice)":              "234🚀 Ints(slice) 🔔 This function sorts a slice of int values. The elements are sorted in place.",
		"ints()":                   "234🚀 Ints(slice) 🔔 This function sorts a slice of int values. The elements are sorted in place.",
		"intsaresorted(slice)":     "234🚀 IntsAreSorted(slice) 🔔 This function returns true if the elements in the specified int slice are in order.",
		"intsaresorted()":          "234🚀 IntsAreSorted(slice) 🔔 This function returns true if the elements in the specified int slice are in order.",
		"strings(slice)":           "234🚀 Strings(slice) 🔔 This function sorts a slice of string values. The elements are sorted in place.",
		"strings()":                "234🚀 Strings(slice) 🔔 This function sorts a slice of string values. The elements are sorted in place.",
		"stringsaresorted(slice)":  "234🚀 StringsAreSorted(slice) 🔔 This function returns true if the elements in the specified string slice are in order.",
		"stringsaresorted()":       "234🚀 StringsAreSorted(slice) 🔔 This function returns true if the elements in the specified string slice are in order.",
		//478.The Key Reflection Functions
		"typeof(val)":  "478🚀 TypeOf(val) 🔔 This function returns a value that implements the Type interface, which describes the type of the specified value. There is a lot of detail behind the TypeOf and ValueOf functions and their results, and it is easy to lose sight of why reflection can be useful.",
		"valueof(val)": "478🚀 ValueOf(val) 🔔 This function returns a Value struct, which allows the specified value to be inspected and manipulated. There is a lot of detail behind the TypeOf and ValueOf functions and their results, and it is easy to lose sight of why reflection can be useful.",
		//481.Basic Methods Defined by the Type Interface
		"name()":             "481🚀 Name() 	🔔 This method returns the name of the type.",
		"pkgpath()":          "481🚀 PkgPath() 	🔔 This method returns the package path for the type. The empty string is returned for built-in types, such as int and bool.",
		"kind()":             "481🚀 Kind() 	🔔 This method returns the kind of type, using a value that matches one of the constant values defined by the reflect package, as described in Table 27-5.",
		"481 string()":       "481🚀 String() 	🔔 This method returns a string representation of the type name, including the package name.",
		"comparable()":       "481🚀 Comparable() 🔔 This method returns true if values of this type can be compared using the standard comparison operator, as described in the “Comparing Values” section.",
		"assignableto(type)": "481🚀 AssignableTo(type) 🔔 This method returns true if values of this type can be assigned to variables or fields of the specified reflected type.",
		"assignableto()":     "481🚀 AssignableTo(type) 🔔 This method returns true if values of this type can be assigned to variables or fields of the specified reflected type.",
		//484.Using the Basic Value Features
		"484 kind()":   "484🚀 Kind()      🔔 This method returns the kind of the value's type.",
		"type()":       "484🚀 Type()      🔔 This method returns the Type for the Value.",
		"isnil()":      "484🚀 IsNil()     🔔 This method returns true if the value is nil. This method will panic if the underlying value isn't a function, an interface, a pointer, a slice, or a channel.",
		"iszero()":     "484🚀 IsZero()    🔔 This method returns true if the underlying value is the zero value for its type.",
		"bool()":       "484🚀 Bool()      🔔 This method returns the underlying bool value. The method panics if the underlying value's Kind is not Bool.",
		"bytes()":      "484🚀 Bytes()     🔔 This method returns the underlying []byte value. The method panics if the underlying value is not a byte slice. I demonstrate how to determine the type of a slice in the “Identifying Byte Slices” section.",
		"484 int()":    "484🚀 Int()       🔔 This method returns the underlying value as an int64. The method panics if the underlying value's Kind is not Int, Int8, Int16, Int32, or Int64.",
		"unit()":       "484🚀 Uint()      🔔 This method returns the underlying value as an uint64. The method panics if the underlying value's Kind is not Uint, Uint8, Uint16, Uint32, or Uint64.",
		"float()":      "484🚀 Float()     🔔 This method returns the underlying value as an float64. The method panics if the underlying value's Kind is not Float32, or Float64.",
		"484 string()": "484🚀 String()    🔔 This method returns the underlying value as a string if the value's Kind is String. For other Kind values, this method returns the string <T Value> where T is the underlying type, such as <int Value>.",
		"elem()":       "484🚀 Elem()      🔔 This method returns the Value to which a pointer refers. This method can also be used with interfaces, as described in Chapter 29. This method panics if the underlying value's Kind is not Ptr.",
		"isvalid()":    "484🚀 IsValid()   🔔 This method returns false if the Value is the zero value, created as Value{} rather than obtained using ValueOf, for example. This method doesn't relate to reflected values that are the zero value of their reflected type. If this method returns false, then all other Value methods will panic.",
		//
		// 🚀🚀🚀🚀🚀🚀 🔔🔔🔔🔔🔔🔔

	},
}

func GetMapReturnSlice() []string {
	// Step 2: Initialize a slice to hold the keys
	var Keys []string

	// Step 3: Iterate over the map and append Keys to the slice
	for key := range OriginSingleDef.SingleDef {
		Keys = append(Keys, key)
	}

	return Keys
}

// ██████████████████████████████████████████████████████████████████████
